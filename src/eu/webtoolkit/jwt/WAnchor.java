/*
 * Copyright (C) 2020 Emweb bv, Herent, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
package eu.webtoolkit.jwt;

import eu.webtoolkit.jwt.chart.*;
import eu.webtoolkit.jwt.servlet.*;
import eu.webtoolkit.jwt.utils.*;
import java.io.*;
import java.lang.ref.*;
import java.time.*;
import java.util.*;
import java.util.regex.*;
import javax.servlet.*;
import javax.servlet.http.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A widget that represents an HTML anchor (to link to other documents).
 *
 * <p>Use an anchor to link to another web page, document, internal application path or a resource
 * (which specifies application-dependent content that may be generated by your application on
 * demand). The anchor may contain a label text, an image, or any other widget (as it inherits from
 * {@link WContainerWidget}).
 *
 * <p>If you link to a document or external url, and do not want the application to terminate when
 * the user follows the anchor, you must use {@link WLink#setTarget(LinkTarget target)
 * link.setTarget(LinkTarget::NewWindow)}. Even for non-HTML documents, this may be important since
 * pending Ajax requests are cancelled if documents are not served within the browser window in
 * certain browsers.
 *
 * <p>WAnchor is an {@link WWidget#setInline(boolean inlined) inline } widget.
 *
 * <p>
 *
 * <h3>CSS</h3>
 *
 * <p>The widget corresponds to the HTML <code>&lt;a&gt;</code> tag and does not provide styling. It
 * can be styled using inline or external CSS as appropriate.
 */
public class WAnchor extends WContainerWidget {
  private static Logger logger = LoggerFactory.getLogger(WAnchor.class);

  /** Creates an anchor. */
  public WAnchor(WContainerWidget parentContainer) {
    super();
    this.linkState_ = new WAnchor.LinkState();
    this.text_ = null;
    this.image_ = null;
    this.flags_ = new BitSet();
    this.setInline(true);
    if (parentContainer != null) parentContainer.addWidget(this);
  }
  /**
   * Creates an anchor.
   *
   * <p>Calls {@link #WAnchor(WContainerWidget parentContainer) this((WContainerWidget)null)}
   */
  public WAnchor() {
    this((WContainerWidget) null);
  }
  /**
   * Creates an anchor for the given link.
   *
   * <p>The <code>link</code> may point to a URL, a dynamic resource, or an internal path.
   *
   * <p>
   *
   * @see WAnchor#setLink(WLink link)
   */
  public WAnchor(final WLink link, WContainerWidget parentContainer) {
    super();
    this.linkState_ = new WAnchor.LinkState();
    this.text_ = null;
    this.image_ = null;
    this.flags_ = new BitSet();
    this.setInline(true);
    this.setLink(link);
    if (parentContainer != null) parentContainer.addWidget(this);
  }
  /**
   * Creates an anchor for the given link.
   *
   * <p>Calls {@link #WAnchor(WLink link, WContainerWidget parentContainer) this(link,
   * (WContainerWidget)null)}
   */
  public WAnchor(final WLink link) {
    this(link, (WContainerWidget) null);
  }
  /**
   * Creates an anchor for the given link with a text.
   *
   * <p>The <code>link</code> may point to a URL, a dynamic resource, or an internal path.
   *
   * <p>
   *
   * @see WAnchor#setLink(WLink link)
   * @see WAnchor#setText(CharSequence text)
   */
  public WAnchor(final WLink link, final CharSequence text, WContainerWidget parentContainer) {
    super();
    this.linkState_ = new WAnchor.LinkState();
    this.text_ = null;
    this.image_ = null;
    this.flags_ = new BitSet();
    this.setInline(true);
    this.setLink(link);
    this.text_ = new WText(text, (WContainerWidget) null);
    this.addWidget(this.text_);
    if (parentContainer != null) parentContainer.addWidget(this);
  }
  /**
   * Creates an anchor for the given link with a text.
   *
   * <p>Calls {@link #WAnchor(WLink link, CharSequence text, WContainerWidget parentContainer)
   * this(link, text, (WContainerWidget)null)}
   */
  public WAnchor(final WLink link, final CharSequence text) {
    this(link, text, (WContainerWidget) null);
  }
  /**
   * Creates an anchor for the given link with an image.
   *
   * <p>
   *
   * @see WAnchor#setLink(WLink link)
   * @see WAnchor#setImage(WImage image)
   */
  public WAnchor(final WLink link, WImage image, WContainerWidget parentContainer) {
    super();
    this.linkState_ = new WAnchor.LinkState();
    this.text_ = null;
    this.image_ = null;
    this.flags_ = new BitSet();
    this.setInline(true);
    this.setLink(link);
    if (image != null) {
      this.image_ = image;
      this.addWidget(image);
    }
    if (parentContainer != null) parentContainer.addWidget(this);
  }
  /**
   * Creates an anchor for the given link with an image.
   *
   * <p>Calls {@link #WAnchor(WLink link, WImage image, WContainerWidget parentContainer) this(link,
   * image, (WContainerWidget)null)}
   */
  public WAnchor(final WLink link, WImage image) {
    this(link, image, (WContainerWidget) null);
  }
  /**
   * Sets the link.
   *
   * <p>The link may hold a URL, a resource, or an internal path.
   *
   * <p>When the link points to a {@link LinkType#Resource resource}, the contents of the link may
   * be generated by your application on demand.
   *
   * <p>When the link points to an {@link LinkType#InternalPath internal path}, activating the
   * anchor will change the {@link WApplication#getInternalPath() application&apos;s internal path}
   * or open a new session with the given path as {@link WEnvironment#getInternalPath() initial
   * path}). This is the easiest way to let the application participate in browser history, and
   * generate URLs that are bookmarkable and search engine friendly.
   */
  public void setLink(final WLink link) {
    if (this.linkState_.link.getType() != LinkType.Resource && this.linkState_.link.equals(link)) {
      return;
    }
    this.linkState_.link = link;
    this.flags_.set(BIT_LINK_CHANGED);
    this.repaint();
    switch (this.linkState_.link.getType()) {
      case Resource:
        this.linkState_
            .link
            .getResource()
            .dataChanged()
            .addListener(
                this,
                () -> {
                  WAnchor.this.resourceChanged();
                });
        break;
      case InternalPath:
        WApplication.getInstance().enableInternalPaths();
        break;
      default:
        break;
    }
  }
  /**
   * Returns the link.
   *
   * <p>
   *
   * @see WAnchor#setLink(WLink link)
   */
  public WLink getLink() {
    return this.linkState_.link;
  }
  /**
   * Sets the label text.
   *
   * <p>If no text was previously set, a new {@link WText} widget is added using {@link
   * WContainerWidget#addWidget(WWidget widget) WContainerWidget#addWidget()}.
   */
  public void setText(final CharSequence text) {
    if (!(this.text_ != null)) {
      WText t = new WText(text, (WContainerWidget) null);
      this.text_ = t;
      this.addWidget(t);
    } else {
      this.text_.setText(text);
    }
  }
  /**
   * Returns the label text.
   *
   * <p>Returns an empty string if no label was set.
   *
   * <p>
   *
   * @see WAnchor#setText(CharSequence text)
   */
  public WString getText() {
    if (this.text_ != null) {
      return this.text_.getText();
    } else {
      return empty;
    }
  }
  /**
   * Configures text word wrapping.
   *
   * <p>When <code>wordWrap</code> is <code>true</code>, the text set with {@link
   * WAnchor#setText(CharSequence text) setText()} may be broken up over multiple lines. When <code>
   * wordWrap</code> is <code>false</code>, the text will displayed on a single line, unless the
   * text contains <code>&lt;br /&gt;</code> tags or other block-level tags.
   *
   * <p>The default value is <code>true</code>.
   *
   * <p>
   *
   * @see WAnchor#hasWordWrap()
   */
  public void setWordWrap(boolean wordWrap) {
    if (!(this.text_ != null)) {
      this.setText(new WString());
    }
    this.text_.setWordWrap(wordWrap);
  }
  /**
   * Configures the text format.
   *
   * <p>The default text format is {@link TextFormat#XHTML}.
   *
   * <p>
   *
   * @see WText#setTextFormat(TextFormat textFormat)
   */
  public void setTextFormat(TextFormat textFormat) {
    if (!(this.text_ != null)) {
      this.setText(new WString());
    }
    this.text_.setTextFormat(textFormat);
  }
  /**
   * Returns the text format.
   *
   * <p>
   *
   * @see WAnchor#setTextFormat(TextFormat textFormat)
   */
  public TextFormat getTextFormat() {
    return this.text_ != null ? this.text_.getTextFormat() : TextFormat.XHTML;
  }
  /**
   * Returns whether the widget may break lines.
   *
   * <p>
   *
   * @see WAnchor#setWordWrap(boolean wordWrap)
   */
  public boolean hasWordWrap() {
    return this.text_ != null ? this.text_.isWordWrap() : true;
  }
  /**
   * Sets an image.
   *
   * <p>If an image was previously set, it is deleted. The <code>image</code> is added using {@link
   * WContainerWidget#addWidget(WWidget widget) WContainerWidget#addWidget()}.
   */
  public void setImage(WImage image) {
    this.image_ = image;
    if (image != null) {
      this.addWidget(image);
    }
  }
  /**
   * Returns the image.
   *
   * <p>Returns <code>null</code> if no image is set.
   *
   * <p>
   *
   * @see WAnchor#setImage(WImage image)
   */
  public WImage getImage() {
    return this.image_;
  }

  public boolean isCanReceiveFocus() {
    return true;
  }

  public int getTabIndex() {
    int result = super.getTabIndex();
    if (result == Integer.MIN_VALUE) {
      return 0;
    } else {
      return result;
    }
  }

  public boolean isSetFirstFocus() {
    return false;
  }

  private static final int BIT_LINK_CHANGED = 0;
  private static final int BIT_TARGET_CHANGED = 1;

  static class LinkState {
    private static Logger logger = LoggerFactory.getLogger(LinkState.class);

    public LinkState() {
      this.link = new WLink();
      this.clickJS = null;
    }

    public WLink link;
    public JSlot clickJS;
  }

  private WAnchor.LinkState linkState_;
  private WText text_;
  private WImage image_;
  BitSet flags_;

  private void resourceChanged() {
    this.flags_.set(BIT_LINK_CHANGED);
    this.repaint();
  }

  static boolean renderHRef(
      WInteractWidget widget, final WAnchor.LinkState linkState, final DomElement element) {
    WApplication app = WApplication.getInstance();
    if (linkState.link.isNull() || widget.isDisabled()) {
      if (app.getEnvironment().hasJavaScript()) {
        element.setAttribute("href", "javascript:void(0);");
      } else {
        element.removeAttribute("href");
      }
    } else {
      String url = linkState.link.resolveUrl(app);
      if (linkState.link.getTarget() == LinkTarget.Self) {
        linkState.clickJS = linkState.link.manageInternalPathChange(app, widget, linkState.clickJS);
      } else {

        linkState.clickJS = null;
      }
      url = app.encodeUntrustedUrl(url);
      String href = url;
      element.setAttribute("href", href);
      return !app.getEnvironment().isInternalPathUsingFragments()
          && href.indexOf("://") == -1
          && href.charAt(0) != '/';
    }
    return false;
  }

  static void renderHTarget(
      final WAnchor.LinkState linkState, final DomElement element, boolean all) {
    switch (linkState.link.getTarget()) {
      case Self:
        if (!all) {
          element.setProperty(Property.Target, "_self");
        }
        break;
      case ThisWindow:
        element.setProperty(Property.Target, "_top");
        break;
      case NewWindow:
        element.setProperty(Property.Target, "_blank");
        break;
      case Download:
        element.setProperty(Property.Target, "wt_iframe_dl");
        element.setProperty(Property.Download, "");
        break;
    }
  }

  static void renderUrlResolution(WWidget widget, final DomElement element, boolean all) {
    if (all) {
      element.setProperty(Property.Class, StringUtils.addWord(widget.getStyleClass(), "Wt-rr"));
    } else {
      element.callJavaScript("Wt4_10_3.$('" + widget.getId() + "').classList.add('Wt-rr');");
    }
  }

  void updateDom(final DomElement element, boolean all) {
    boolean needsUrlResolution = false;
    if (this.flags_.get(BIT_LINK_CHANGED) || all) {
      needsUrlResolution = renderHRef(this, this.linkState_, element);
      this.flags_.clear(BIT_LINK_CHANGED);
    }
    if (this.flags_.get(BIT_TARGET_CHANGED) || all) {
      renderHTarget(this.linkState_, element, all);
      this.flags_.clear(BIT_TARGET_CHANGED);
    }
    super.updateDom(element, all);
    if (needsUrlResolution) {
      renderUrlResolution(this, element, all);
    }
  }

  DomElementType getDomElementType() {
    return DomElementType.A;
  }

  void propagateRenderOk(boolean deep) {
    this.flags_.clear(BIT_LINK_CHANGED);
    this.flags_.clear(BIT_TARGET_CHANGED);
    super.propagateRenderOk(deep);
  }

  protected void propagateSetEnabled(boolean enabled) {
    super.propagateSetEnabled(enabled);
    this.resourceChanged();
  }

  protected void enableAjax() {
    if (this.linkState_.link.getType() == LinkType.InternalPath) {
      this.flags_.set(BIT_LINK_CHANGED);
      this.repaint();
    }
    super.enableAjax();
  }

  static WString empty = new WString("");
}
