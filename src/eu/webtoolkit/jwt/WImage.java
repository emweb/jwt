/*
 * Copyright (C) 2020 Emweb bv, Herent, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
package eu.webtoolkit.jwt;

import eu.webtoolkit.jwt.chart.*;
import eu.webtoolkit.jwt.servlet.*;
import eu.webtoolkit.jwt.utils.*;
import java.io.*;
import java.lang.ref.*;
import java.time.*;
import java.util.*;
import java.util.regex.*;
import javax.servlet.*;
import javax.servlet.http.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A widget that displays an image.
 *
 * <p>The image may be specified either as a URL, or may be dynamically generated by a {@link
 * WResource}.
 *
 * <p>You may listen to events by attaching event listeners to signals such as {@link
 * WInteractWidget#clicked()}. Since mouse events pass the coordinates through a {@link WMouseEvent}
 * object, it is possible to react to clicks in specific parts of the image. An alternative is to
 * define interactive areas on the image using {@link WImage#addArea(WAbstractArea area) addArea()},
 * which in addition allows to have customized tool tips for certain image areas (using {@link
 * WAbstractArea#setToolTip(CharSequence text) WAbstractArea#setToolTip()}).
 *
 * <p>WImage is an {@link WWidget#setInline(boolean inlined) inline } widget.
 *
 * <p>
 *
 * <h3>CSS</h3>
 *
 * <p>The widget corresponds to the HTML <code>&lt;img&gt;</code> tag and does not provide styling.
 * It can be styled using inline or external CSS as appropriate.
 *
 * <p>
 *
 * @see WResource
 * @see WPaintedWidget
 */
public class WImage extends WInteractWidget {
  private static Logger logger = LoggerFactory.getLogger(WImage.class);

  /** Creates an empty image widget. */
  public WImage(WContainerWidget parentContainer) {
    super();
    this.altText_ = new WString();
    this.imageLink_ = new WLink();
    this.map_ = null;
    this.flags_ = new BitSet();
    this.targetJS_ = "";
    this.setLoadLaterWhenInvisible(false);
    if (parentContainer != null) parentContainer.addWidget(this);
  }
  /**
   * Creates an empty image widget.
   *
   * <p>Calls {@link #WImage(WContainerWidget parentContainer) this((WContainerWidget)null)}
   */
  public WImage() {
    this((WContainerWidget) null);
  }
  /**
   * Creates an image widget with a given image link.
   *
   * <p>The <code>imageLink</code> may link to a URL or resource.
   */
  public WImage(final WLink link, WContainerWidget parentContainer) {
    super();
    this.altText_ = new WString();
    this.imageLink_ = new WLink();
    this.map_ = null;
    this.flags_ = new BitSet();
    this.targetJS_ = "";
    this.setLoadLaterWhenInvisible(false);
    this.setImageLink(link);
    if (parentContainer != null) parentContainer.addWidget(this);
  }
  /**
   * Creates an image widget with a given image link.
   *
   * <p>Calls {@link #WImage(WLink link, WContainerWidget parentContainer) this(link,
   * (WContainerWidget)null)}
   */
  public WImage(final WLink link) {
    this(link, (WContainerWidget) null);
  }
  /**
   * Creates an image widget with a given image link and alternate text.
   *
   * <p>The <code>imageLink</code> may link to a URL or resource.
   */
  public WImage(final WLink link, final CharSequence altText, WContainerWidget parentContainer) {
    super();
    this.altText_ = WString.toWString(altText);
    this.imageLink_ = new WLink();
    this.map_ = null;
    this.flags_ = new BitSet();
    this.targetJS_ = "";
    this.setLoadLaterWhenInvisible(false);
    this.setImageLink(link);
    if (parentContainer != null) parentContainer.addWidget(this);
  }
  /**
   * Creates an image widget with a given image link and alternate text.
   *
   * <p>Calls {@link #WImage(WLink link, CharSequence altText, WContainerWidget parentContainer)
   * this(link, altText, (WContainerWidget)null)}
   */
  public WImage(final WLink link, final CharSequence altText) {
    this(link, altText, (WContainerWidget) null);
  }

  public void remove() {
    {
      WWidget oldWidget = this.map_;
      this.map_ = null;
      {
        WWidget toRemove = this.manageWidget(oldWidget, this.map_);
        if (toRemove != null) toRemove.remove();
      }
    }
    super.remove();
  }
  /**
   * Sets an alternate text.
   *
   * <p>The alternate text should provide a fallback for browsers that do not display an image. If
   * no sensible fallback text can be provided, an empty text is preferred over nonsense.
   *
   * <p>This should not be confused with {@link WWebWidget#getToolTip()} text, which provides
   * additional information that is displayed when the mouse hovers over the image.
   *
   * <p>The default alternate text is an empty text (&quot;&quot;).
   *
   * <p>
   *
   * @see WImage#getAlternateText()
   */
  public void setAlternateText(final CharSequence text) {
    if (canOptimizeUpdates() && (text.toString().equals(this.altText_.toString()))) {
      return;
    }
    this.altText_ = WString.toWString(text);
    this.flags_.set(BIT_ALT_TEXT_CHANGED);
    this.repaint();
  }
  /**
   * Returns the alternate text.
   *
   * <p>
   *
   * @see WImage#setAlternateText(CharSequence text)
   */
  public WString getAlternateText() {
    return this.altText_;
  }
  /**
   * Sets the image link.
   *
   * <p>The image may be specified as a URL or as a resource. A resource specifies
   * application-dependent content, which may be used to generate an image on demand.
   */
  public void setImageLink(final WLink link) {
    if (link.getType() != LinkType.Resource
        && canOptimizeUpdates()
        && link.equals(this.imageLink_)) {
      return;
    }
    this.imageLink_ = link;
    if (link.getType() == LinkType.Resource) {
      link.getResource()
          .dataChanged()
          .addListener(
              this,
              () -> {
                WImage.this.resourceChanged();
              });
    }
    this.flags_.set(BIT_IMAGE_LINK_CHANGED);
    this.repaint(EnumSet.of(RepaintFlag.SizeAffected));
  }
  /** Returns the image link. */
  public WLink getImageLink() {
    return this.imageLink_;
  }
  /**
   * Adds an interactive area.
   *
   * <p>Adds the <code>area</code> which listens to events in a specific region of the image. Areas
   * are organized in an indexed list, to which the given <code>area</code> is appended. When areas
   * overlap, the area with the lowest index receives the event.
   *
   * <p>Ownership of the <code>area</code> is transferred to the image.
   *
   * <p>
   *
   * <p><i><b>Note: </b>Currently it is not possible to add a first area after the image has been
   * rendered. If you want to use interactive areas you need to add one immediately. </i>
   */
  public void addArea(WAbstractArea area) {
    this.insertArea(this.map_ != null ? this.map_.getCount() : 0, area);
  }
  // public Area  addArea(<Woow... some pseudoinstantiation type!> area) ;
  /**
   * Inserts an interactive area.
   *
   * <p>Inserts the <code>area</code> which listens to events in the coresponding area of the image.
   * Areas are organized in a list, and the <i>area</i> is inserted at index <code>index</code>.
   * When areas overlap, the area with the lowest index receives the event.
   *
   * <p>Ownership of the <code>area</code> is transferred to the image.
   *
   * <p>
   *
   * @see WImage#addArea(WAbstractArea area)
   *     <p><i><b>Note: </b>Currently it is not possible to add a first area after the image has
   *     been rendered. If you want to use interactive areas you need to add one immediately. </i>
   */
  public void insertArea(int index, WAbstractArea area) {
    if (!(this.map_ != null)) {
      MapWidget map = new MapWidget();
      {
        WWidget oldWidget = this.map_;
        this.map_ = map;
        {
          WWidget toRemove = this.manageWidget(oldWidget, this.map_);
          if (toRemove != null) toRemove.remove();
        }
      }
      this.flags_.set(BIT_MAP_CREATED);
      this.repaint();
    }
    this.map_.insertArea(index, area);
  }
  // public Area  insertArea(int index, <Woow... some pseudoinstantiation type!> area) ;
  /**
   * Removes an interactive area.
   *
   * <p>Removes the <code>area</code> from this widget.
   *
   * <p>
   */
  public WAbstractArea removeArea(WAbstractArea area) {
    WAbstractArea result = null;
    if (this.map_ != null) {
      result = this.map_.removeArea(area);
    }
    if (!(result != null)) {
      logger.error(new StringWriter().append("removeArea(): area was not found").toString());
    }
    return result;
  }
  /**
   * Returns the interactive area at the given index.
   *
   * <p>Returns <code>null</code> if <code>index</code> was invalid.
   *
   * <p>
   */
  public WAbstractArea getArea(int index) {
    if (this.map_ != null && index < this.map_.getCount()) {
      return this.map_.area(index);
    } else {
      return null;
    }
  }
  /**
   * Returns the interactive areas set for this widget.
   *
   * <p>
   *
   * @see WImage#addArea(WAbstractArea area)
   */
  public List<WAbstractArea> getAreas() {
    List<WAbstractArea> result = new ArrayList<WAbstractArea>();
    if (this.map_ != null) {
      for (int i = 0; i < this.map_.getCount(); ++i) {
        result.add(this.map_.area(i));
      }
    }
    return result;
  }
  /** Event emitted when the image was loaded. */
  public EventSignal imageLoaded() {
    return this.voidEventSignal(LOAD_SIGNAL, true);
  }

  public void setTargetJS(String targetJS) {
    this.targetJS_ = targetJS;
  }

  public String getUpdateAreasJS() {
    StringBuilder ss = new StringBuilder();
    if (this.targetJS_.length() != 0) {
      ss.append("(function(){var w = ")
          .append(this.getJsRef())
          .append(";if (w && w.wtObj) { w.wtObj.updateAreas(); }})();");
    }
    return ss.toString();
  }

  public String getSetAreaCoordsJS() {
    StringBuilder ss = new StringBuilder();
    if (this.targetJS_.length() != 0) {
      ss.append(this.getJsRef())
          .append(".wtObj.setAreaCoordsJSON(")
          .append(this.getUpdateAreaCoordsJSON())
          .append(");");
    }
    return ss.toString();
  }

  private static String LOAD_SIGNAL = "load";
  private static final int BIT_ALT_TEXT_CHANGED = 0;
  private static final int BIT_IMAGE_LINK_CHANGED = 1;
  private static final int BIT_MAP_CREATED = 2;
  private WString altText_;
  private WLink imageLink_;
  private MapWidget map_;
  BitSet flags_;
  String targetJS_;

  private void resourceChanged() {
    this.flags_.set(BIT_IMAGE_LINK_CHANGED);
    this.repaint(EnumSet.of(RepaintFlag.SizeAffected));
  }

  protected void getDomChanges(final List<DomElement> result, WApplication app) {
    if (this.map_ != null) {
      DomElement e = DomElement.getForUpdate("i" + this.getId(), DomElementType.IMG);
      this.updateDom(e, false);
      result.add(e);
    } else {
      super.getDomChanges(result, app);
    }
  }

  void updateDom(final DomElement element, boolean all) {
    DomElement img = element;
    if (all && element.getType() == DomElementType.SPAN) {
      DomElement map = this.map_.createSDomElement(WApplication.getInstance());
      element.addChild(map);
      img = DomElement.createNew(DomElementType.IMG);
      img.setId("i" + this.getId());
    }
    if (this.flags_.get(BIT_IMAGE_LINK_CHANGED) || all) {
      String url = "";
      WApplication app = WApplication.getInstance();
      if (!this.imageLink_.isNull()) {
        url = resolveRelativeUrl(this.imageLink_.getUrl());
        url = app.encodeUntrustedUrl(url);
      } else {
        url = app.getOnePixelGifUrl();
      }
      img.setProperty(Property.Src, url);
      this.flags_.clear(BIT_IMAGE_LINK_CHANGED);
    }
    if (this.flags_.get(BIT_ALT_TEXT_CHANGED) || all) {
      img.setAttribute("alt", this.altText_.toString());
      this.flags_.clear(BIT_ALT_TEXT_CHANGED);
    }
    if (this.flags_.get(BIT_MAP_CREATED) || all && this.map_ != null) {
      img.setAttribute("usemap", '#' + this.map_.getId());
      this.flags_.clear(BIT_MAP_CREATED);
    }
    super.updateDom(img, all);
    if (element != img) {
      element.addChild(img);
    }
  }

  protected void defineJavaScript() {
    WApplication app = WApplication.getInstance();
    app.loadJavaScript("js/WImage.js", wtjs1());
    StringBuilder ss = new StringBuilder();
    ss.append("new Wt4_10_3.WImage(")
        .append(app.getJavaScriptClass())
        .append(",")
        .append(this.getJsRef())
        .append(",")
        .append(this.targetJS_)
        .append(");");
    this.doJavaScript(ss.toString());
  }

  protected void render(EnumSet<RenderFlag> flags) {
    if (flags.contains(RenderFlag.Full)) {
      if (this.targetJS_.length() != 0) {
        this.defineJavaScript();
      }
    }
    super.render(flags);
  }

  DomElementType getDomElementType() {
    return this.map_ != null ? DomElementType.SPAN : DomElementType.IMG;
  }

  void propagateRenderOk(boolean deep) {
    this.flags_.clear(BIT_IMAGE_LINK_CHANGED);
    this.flags_.clear(BIT_ALT_TEXT_CHANGED);
    super.propagateRenderOk(deep);
  }

  protected String getUpdateAreaCoordsJSON() {
    StringBuilder js = new StringBuilder();
    final List<WAbstractArea> areas = this.getAreas();
    if (!areas.isEmpty()) {
      for (int i = 0; i < areas.size(); ++i) {
        if (areas.get(i).isTransformable()) {
          if ((js.length() == 0)) {
            js.append("[");
          } else {
            js.append(",");
          }
          js.append(areas.get(i).getUpdateAreaCoordsJS());
        }
      }
      js.append("]");
    } else {
      js.append("null");
    }
    return js.toString();
  }

  static WJavaScriptPreamble wtjs1() {
    return new WJavaScriptPreamble(
        JavaScriptScope.WtClassScope,
        JavaScriptObjectType.JavaScriptConstructor,
        "WImage",
        "(function(t,e,r){e.wtObj=this;const o=this,n=100;let i=null,s=0,u=\"\",a=null,l=0;this.setAreaCoordsJSON=function(t){i=t;u=\"\";this.updateAreas()};this.updateAreas=function(){const t=r.combinedTransform;if(void 0===t||null===i)return;const e=t(),c=e.toString()!==u.toString();if(0===s&&0===l){if(c){u=e;s=(new Date).getTime();a=setTimeout(this.updateAreas,n);return}return}const d=(new Date).getTime();if(c){u=e;s=d;l=0;a&&clearTimeout(a);a=setTimeout(this.updateAreas,n)}else if(l>0||s&&d-s>n){if(o.updateAreaCoords(50)){s=0;l=0;a&&clearTimeout(a);a=null;return}a&&clearTimeout(a);a=setTimeout(o.updateAreas,0)}else{let t=d-s;t>n&&(t=n);a&&clearTimeout(a);a=setTimeout(o.updateAreas,t)}};this.updateAreaCoords=function(e){const r=t.WT.gfxUtils.transform_mult;let o=l+e;o>i.length&&(o=i.length);for(;l<o;){const t=i[l],e=t[0],o=t[1],n=o.length;let s=\"\",a=0;for(;a+1<n;a+=2){a>0&&(s+=\",\");const t=r(u,o.slice(a,a+2));s+=Math.round(t[0]).toString()+\",\"+Math.round(t[1]).toString()}a<n&&(s+=\",\"+o[a].toString());e&&(e.coords=s);l++}return o===i.length}})");
  }
}
