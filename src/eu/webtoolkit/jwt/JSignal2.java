/*
 * Copyright (C) 2009 Emweb bv, Herent, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
package eu.webtoolkit.jwt;

import java.lang.reflect.ParameterizedType;

import eu.webtoolkit.jwt.Signal.Listener;

/**
 * A signal to relay JavaScript to Java calls, passing 2 arguments.
 * 
 * <p>
 * The signal is identified by a unique name within the scope of a {@link WObject}, 
 * or a unique global name (when declaring the signal in your {@link WApplication}).
 * <p>
 * The argument types A1 and A2 must be a {@link String}, {@link WString}, or a wrapper class
 * of one of the Java primitive types. Values of the corresponding JavaScript types can be passed 
 * to the JavaScript call.
 * <p>
 * Note that this is an abstract class. To create a JSignal, you should specialize this class, but
 * you do not need to specialize any method. The reason for this is to circumvent limitations in
 * Java to obtain introspection in the types of the arguments, and provide suitable marshaling
 * of data from JavaScript to Java. The easiest way to instantiate an object of this class is:
 * <pre>
 *   JSignal2&lt;String, Integer&gt; pingSignal = new JSignal2&lt;String, Integer&gt;(this, "pingSignal") { };
 * </pre>
 * <p>
 * Example code:
 * <pre>
 * class MyWidget extends WCompositeWidget
 * {
 *     public MyWidget() {
 *         doSome = new JSignal2&lt;String, Integer&gt;(this, "doSome") { };
 *          ...
 *     }
 *
 *     JSignal&lt;String, Integer&gt; doSome() { return doSome; }
 *
 *     private JSignal2&lt;String, Integer&gt; doSome;
 * }
 * </pre>
 * <p>
 * The following JavaScript statement will emit the signal for a 
 * DOM element element that corresponds to a widget of class MyWidget:
 * <pre>
 *  Wt.emit(element, 'dosome', 'foo', 42);
 * </pre>
 * <p>
 * The <i>element</i> can be a DOM element, or the object ID of a WObject, 
 * or the constant 'Wt' which is an alias for WApplication's id. 
 * <p>
 * You can use the methods {@link #createCall(String arg1, String arg2)} to 
 * let the signal itself generate this JavaScript call for you:
 * <pre>
 *   doSome_.createCall("'foo'", "42");
 * </pre>
 * <p>
 * The JavaScript generated by {@link #createCall(String arg1, String arg2)} is possibly 
 * affected by every connect or disconnect to the signal. 
 * In practice, you will use this class internally within a widget and call 
 * {@link #createCall(String arg1, String arg2)} only after you connected internal slots to signal.
 * <p>
 * It is also possible to propagate an original JavaScript event as a last argument, 
 * of type {@link WMouseEvent} or {@link WKeyEvent}. 
 * In that case, the second argument in Wt.emit() must be an object which indicates 
 * also the JavaScript event and event target.
 * <p>
 * Consider a signal declaration:
 * <pre>
 *  JSignal2&lt;String, Integer, WMouseEvent&gt; doSome();
 * </pre>
 * <p>
 * Then, the following would be a suitable JavaScript call:
 * <pre>
 *  Wt.emit(Wt, {name: 'dosome', event: event, eventObject: object}, 'foo', 42);
 * </pre>
 */
public abstract class JSignal2<A1, A2> extends AbstractJSignal {
	private Signal2<A1, A2> dynamic_;

	JSignal2(WObject sender, String name, boolean collectSlotJavaScript) {
		super(sender, name, collectSlotJavaScript);

		dynamic_ = null;
	}
	
	/**
	 * Creates a signal.
	 * 
	 * @param sender the object that will be identified as the sender for this signal.
	 * @param name the signal name (must be unique for each sender)
	 */
	public JSignal2(WObject sender, String name) {
		this(sender, name, false);
	}

	/**
	 * Adds a listener for this signal.
	 * <p>
	 * Each listener will be triggered whenever the signal is triggered.
	 * 
	 * @param listenerOwner
	 *            the enclosing object for a listener implemented using an (anonymous) inner class
	 * @param listener
	 *            the listener
	 * @return a connection object that may be used to control the connection
	 * 
	 * @see AbstractSignal#addListener(WObject, eu.webtoolkit.jwt.Signal.Listener)
	 */
	public Connection addListener(WObject listenerOwner, Signal2.Listener<A1, A2> listener) {
		if (dynamic_ == null)
			dynamic_ = new Signal2<A1, A2>(getSender());

		Connection c = dynamic_.addListener(listenerOwner, listener);

		super.listenerAdded();

		return c;
	}

	@Override
	protected int getListenerCount() {
		return super.getListenerCount() + (dynamic_ != null ? dynamic_.getListenerCount() : 0);
	}

	/**
	 * Removes a listener.
	 * 
	 * @param listener a listener that was previously added
	 */
	public void removeListener(Signal2.Listener<A1, A2> listener) {
		if (dynamic_ != null)
			dynamic_.removeListener(listener);

		super.listenerRemoved();
	}

	/**
	 * Triggers the signal.
	 * <p>
	 * The arguments are passed to the listeners.
	 * 
	 * @param arg1 Argument 1
	 * @param arg2 Argument 2
	 */
	public void trigger(A1 arg1, A2 arg2) {
		if (dynamic_ != null)
			dynamic_.trigger(arg1, arg2);

		super.trigger();
	}

	/**
	 * Returns a JavaScript statement that triggers this signal.
	 * <p>
	 * You can use this to trigger the signal from within generated JavaScript code.
	 * 
	 * @param arg1 JavaScript argument 1.
	 * @param arg2 JavaScript argument 2.
	 */
	public String createCall(String arg1, String arg2) {
		return createUserEventCall(null, null, arg1, arg2, null, null, null, null);
	}

	@SuppressWarnings("unchecked")
	@Override
	void processDynamic(JavaScriptEvent jsEvent) {
		ParameterizedType parameterizedType =  
		    (ParameterizedType) getClass().getGenericSuperclass();
		Class A1Class= (Class) parameterizedType.getActualTypeArguments()[0];
		A1 a1 = (A1) unMarshal(jsEvent, 0, A1Class);
		Class A2Class= (Class) parameterizedType.getActualTypeArguments()[1];
		A2 a2 = (A2) unMarshal(jsEvent, 1, A2Class);
		trigger(a1, a2);
	}

	@Override
	public Connection addListener(WObject listenerOwner, final Signal.Listener listener) {
		if (dynamic_ == null)
			dynamic_ = new Signal2<A1, A2>(getSender());

		Connection c = dynamic_.addListener(listenerOwner, listener);

		super.listenerAdded();

		return c;
	}

	@Override
	public void removeListener(Listener listener) {
		if (dynamic_ != null)
			dynamic_.removeListener(listener);
	}
	
	@Override
	protected int getArgumentCount() {
		return 2;
	}
}
