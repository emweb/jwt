/*
 * Copyright (C) 2020 Emweb bv, Herent, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
package eu.webtoolkit.jwt;

import java.util.*;
import java.util.regex.*;
import java.io.*;
import java.lang.ref.*;
import java.time.*;
import java.util.concurrent.locks.ReentrantLock;
import m4_changequote(`°°°')m4_ifelse(CLASSIFIER,°°°javax',°°°javax',°°°jakarta').servlet.http.*;
import m4_ifelse(CLASSIFIER,°°°javax',°°°javax',°°°jakarta').servlet.*;
import eu.webtoolkit.jwt.*;
import eu.webtoolkit.jwt.auth.*;
import eu.webtoolkit.jwt.auth.mfa.*;
import eu.webtoolkit.jwt.chart.*;
import eu.webtoolkit.jwt.utils.*;
import eu.webtoolkit.jwt.servlet.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

 class FlexLayoutImpl extends StdLayoutImpl {
  private static Logger logger = LoggerFactory.getLogger(FlexLayoutImpl.class);
  
  public  FlexLayoutImpl(WLayout  layout, final Grid grid) {
  super (layout);
  this.flags_ = new BitSet();
  this.grid_ = grid;
  this.addedItems_ = new ArrayList<WLayoutItem>();
  this.resizedItems_ = new ArrayList<WLayoutItem>();
  this.removedItems_ = new ArrayList<String>();
  this.childLayouts_ = new ArrayList<StdLayoutImpl>();
  this.elId_ = "";
  this.canAdjustLayout_ = false;
   String  THIS_JS ="js/FlexLayoutImpl.js";
   WApplication  app =WApplication.getInstance();
  if (!  app.isJavaScriptLoaded(THIS_JS)) { 
     app.loadJavaScript (THIS_JS, wtjs1 ());
}
   WContainerWidget  c = this.getContainer();
  if ( c != null) { 
     c.setFlexBox (true);
}
  }
  public int getMinimumWidth() {
   final int colCount =    this.grid_.columns_.size ();
   int total =0;
  for ( int i =0; 
  i < colCount;++ i) {
    total +=   this.minimumWidthForColumn (i);
}
  return  total +  ( colCount - 1) *    this.grid_.horizontalSpacing_;
  }
  public int getMinimumHeight() {
   final int rowCount =    this.grid_.rows_.size ();
   int total =0;
  for ( int i =0; 
  i < rowCount;++ i) {
    total +=   this.minimumHeightForRow (i);
}
  return  total +  ( rowCount - 1) *    this.grid_.verticalSpacing_;
  }
  public int getMaximumWidth() {
   final int colCount =    this.grid_.columns_.size ();
   int total =0;
  for ( int i =0; 
  i < colCount;++ i) {
     int colMax =  this.maximumWidthForColumn (i);
    if ( colMax == 0) {
      return 0;
    }
    total += colMax;
}
  return  total +  ( colCount - 1) *    this.grid_.horizontalSpacing_;
  }
  public int getMaximumHeight() {
   final int rowCount =    this.grid_.rows_.size ();
   int total =0;
  for ( int i =0; 
  i < rowCount;++ i) {
     int rowMax =  this.maximumHeightForRow (i);
    if ( rowMax == 0) {
      return 0;
    }
    total += rowMax;
}
  return  total +  ( rowCount - 1) *    this.grid_.verticalSpacing_;
  }
  public void itemAdded(WLayoutItem  item) {
    this.addedItems_.add(item);
 StdLayoutImpl  child =getStdLayoutImpl (item);
  if ( child != null) {
      this.childLayouts_.add(child);
} 
   this.update ();
}
  public void itemRemoved(WLayoutItem  item) {
    this.addedItems_.remove(item);
 StdLayoutImpl  child =getStdLayoutImpl (item);
  if ( child != null) {
      this.childLayouts_.remove(child);
}
    this.removedItems_.add( getImpl (item).getId());
  this.update ();
}
  public void updateDom(final DomElement parent) {
   WApplication  app =WApplication.getInstance();
   DomElement  div =DomElement.getForUpdate (  this.elId_, DomElementType.DIV);
  if (   this.flags_.get(BIT_OBJECT_NAME_CHANGED) &&    this.getLayout().getParentLayout() != null) {
    if ( this.getObjectName().length()!=0) { 
       div.setAttribute ("data-object-name",  this.getObjectName());
}
    else  { 
       div.removeAttribute ("data-object-name");
}
      this.flags_.clear(BIT_OBJECT_NAME_CHANGED);
}
   boolean skipLayoutAdjust =false;
   Orientation orientation =  this.getOrientation ();
  if (     this.grid_.items_.size () > 0) {
     WWidget  layoutParentWidget =    this.item (orientation, 0).item_.getParentWidget();
    if (  layoutParentWidget != null && !   layoutParentWidget.isEnabled ()) {
      skipLayoutAdjust = true;
}
  }
   List<Integer> orderedInserts  = new ArrayList<Integer>();
  for ( int i =0; 
  i <    this.addedItems_.size ();++ i) {
    orderedInserts.add(  this.indexOf (  this.addedItems_.get(i), orientation));
  this.resizedItems_.add(  this.addedItems_.get(i));
}
  Collections.sort(orderedInserts);
 int totalStretch =  this.getTotalStretch (orientation);
  for ( int i =0; 
  i <  orderedInserts.size ();++ i) {
     int pos =orderedInserts.get(i);
     DomElement  el =  this.createElement (orientation, pos, totalStretch, app); 
     div.insertChildAt (el, pos);
}
  for ( int i =0; 
  i <    this.childLayouts_.size ();++ i) {
     boolean justAdded =false;
     WLayoutItem  childItem =   this.childLayouts_.get(i).getLayoutItem();
    for ( int j =0;  
    j <    this.addedItems_.size () && ! justAdded;++ j) {
      justAdded =  childItem ==   this.addedItems_.get(j);
}
    if (! justAdded) { 
         this.childLayouts_.get(i).updateDom ( div);
}
  } 
    this.addedItems_.clear ();
for ( int i =0; 
  i <    this.resizedItems_.size ();++ i) {
     WWidget  item =   this.resizedItems_.get(i).getWidget();
     StringBuilder method  = new StringBuilder();
    method.append("layout.resizeItem(").append( item.getId()).append(",").append('"').append( item.getWidth().getCssText()).append("\",").append('"').append( item.getHeight().getCssText()).append("\",").append(")");
  div.callMethod (method.toString());
} 
    this.resizedItems_.clear ();
for ( int i =0; 
  i <    this.removedItems_.size ();++ i) { 
     div.callJavaScript (  "Wt4_12_2.remove('" +   this.removedItems_.get(i) + "');", true);
} 
    this.removedItems_.clear ();
if (  this.canAdjustLayout_) { 
     div.callMethod ("layout.adjust()");
}
  if ( !   this.canAdjustLayout_ && skipLayoutAdjust) {  
    this.canAdjustLayout_ = true;
} 
  parent.addChild (div);
}
  public DomElement  createDomElement(DomElement  parent, boolean fitWidth, boolean fitHeight, WApplication  app) { 
    this.addedItems_.clear ();
   this.removedItems_.clear ();
 int[] margin = {
    0,
    0,
    0,
    0
  };
   DomElement  result ;
  if (   this.getLayout().getParentLayout() == null) {
    if (  this.getContainer() ==  app.getRoot()) { 
       app.setBodyClass (  app.getBodyClass() + " Wt-layout");
  app.setHtmlClass (  app.getHtmlClass() + " Wt-layout");
  parent.setProperty (Property.StyleBoxSizing, "border-box");
}  
    margin[3] =    this.getLayout().getContentsMargin (Side.Left);
  margin[0] =    this.getLayout().getContentsMargin (Side.Top);
  margin[1] =    this.getLayout().getContentsMargin (Side.Right);
  margin[2] =    this.getLayout().getContentsMargin (Side.Bottom);
 Orientation orientation =  this.getOrientation ();
    if ( orientation == Orientation.Horizontal) {  
      margin[3] = Math.max(0,   margin[3]);
  margin[1] = Math.max(0,   margin[1]);
}
    else  {  
      margin[0] = Math.max(0,   margin[0]);
  margin[2] = Math.max(0,   margin[2]);
}
    ResizeSensor.applyIfNeeded ( this.getContainer());
result = parent;
   this.elId_=    this.getContainer().getId();
}
  else  {
    result = DomElement.createNew (DomElementType.DIV);
   this.elId_=   this.getId();
  result.setId (  this.elId_);
  result.setProperty (Property.StyleDisplay,  this.getStyleDisplay());
if ( this.getObjectName().length()!=0) { 
       result.setAttribute ("data-object-name",  this.getObjectName());
}
  }
  if (      margin[0] != 0 ||    margin[1] != 0 ||    margin[2] != 0 ||    margin[3] != 0) {
     StringBuilder paddingProperty  = new StringBuilder();
    paddingProperty.append(  margin[0]).append("px ").append(  margin[1]).append("px ").append(  margin[2]).append("px ").append(  margin[3]).append("px");
  result.setProperty (Property.StylePadding, paddingProperty.toString());
} 
   result.setProperty (Property.StyleFlexFlow,  this.getStyleFlex());
 Orientation orientation =  this.getOrientation ();
   int c =  this.count (orientation);
   int totalStretch =  this.getTotalStretch (orientation);
  for ( int i =0; 
  i < c;++ i) {
     DomElement  el =  this.createElement (orientation, i, totalStretch, app); 
     result.addChild (el);
}
   StringBuilder js  = new StringBuilder();
  js.append("layout=new Wt4_12_2.FlexLayout(").append( app.getJavaScriptClass()).append(",").append("'").append(  this.elId_).append("',").append("'").append(  this.getContainer().getId()).append("');");
  result.callMethod (js.toString());
return result;
  }
  public boolean itemResized(WLayoutItem  item) {
  if ( item != null) {
      this.resizedItems_.add(item);
} 
   this.update ();
return true;
  }
  public boolean isParentResized() { 
   this.update ();
return false;
  }
  public void setObjectName(final String name) {
  if (!  this.getObjectName().equals(name)) { 
     super.setObjectName (name);
   this.flags_.set (BIT_OBJECT_NAME_CHANGED);
  this.update ();
}
  }
  private static final int BIT_OBJECT_NAME_CHANGED =0;
  private BitSet flags_ ;
  private final Grid grid_ ;
  private List<WLayoutItem> addedItems_ ;
  private List<WLayoutItem> resizedItems_ ;
  private List<String> removedItems_ ;
  private List<StdLayoutImpl> childLayouts_ ;
  private String elId_ ;
  private boolean canAdjustLayout_ ;
  private int minimumHeightForRow(int row) {
   int minHeight =0;
   final int colCount =    this.grid_.columns_.size ();
  for ( int j =0; 
  j < colCount;++ j) {
     WLayoutItem  item =    this.grid_.items_.get(row).get(j).item_;
    if ( item != null) {
      minHeight = Math.max(minHeight,  getImpl (item).getMinimumHeight());
}
  }
  return minHeight;
  }
  private int minimumWidthForColumn(int col) {
   int minWidth =0;
   final int rowCount =    this.grid_.rows_.size ();
  for ( int i =0; 
  i < rowCount;++ i) {
     WLayoutItem  item =    this.grid_.items_.get(i).get(col).item_;
    if ( item != null) {
      minWidth = Math.max(minWidth,  getImpl (item).getMinimumWidth());
}
  }
  return minWidth;
  }
  private int maximumHeightForRow(int row) {
   int maxHeight =Integer.MAX_VALUE;
   boolean isConstrained =false;
   final int colCount =    this.grid_.columns_.size ();
  for ( int j =0; 
  j < colCount;++ j) {
     WLayoutItem  item =    this.grid_.items_.get(row).get(j).item_;
    if ( item != null) {
       int itemMaxHeight = getImpl (item).getMaximumHeight();
      if ( itemMaxHeight > 0) {
        if (isConstrained) {
          maxHeight = Math.min(maxHeight, itemMaxHeight);
}
        else  {
          maxHeight = itemMaxHeight;
isConstrained = true;
}
      }
    }
  }
  if (! isConstrained) {
    maxHeight = 0;
}
  return maxHeight;
  }
  private int maximumWidthForColumn(int col) {
   int maxWidth =Integer.MAX_VALUE;
   boolean isConstrained =false;
   final int rowCount =    this.grid_.rows_.size ();
  for ( int i =0; 
  i < rowCount;++ i) {
     WLayoutItem  item =    this.grid_.items_.get(i).get(col).item_;
    if ( item != null) {
       int itemMaxWidth = getImpl (item).getMaximumWidth();
      if ( itemMaxWidth > 0) {
        if (isConstrained) {
          maxWidth = Math.min(maxWidth, itemMaxWidth);
}
        else  {
          maxWidth = itemMaxWidth;
isConstrained = true;
}
      }
    }
  }
  if (! isConstrained) {
    maxWidth = 0;
}
  return maxWidth;
  }
  private DomElement  createElement(Orientation orientation, int index, int totalStretch, WApplication  app) {
   final Grid.Item it =  this.item (orientation, index);
   final Grid.Section s =  this.section (orientation, index);
   DomElement  el =  getImpl ( it.item_).createDomElement ((DomElement)null, true, true, app);
  if ( ObjectUtils.cast(getImpl ( it.item_), StdGridLayoutImpl2.class) != null) {
     DomElement  wrapEl =DomElement.createNew (DomElementType.DIV); 
     wrapEl.addChild (el);
el = wrapEl;
}
   int[] m = {
    0,
    0,
    0,
    0
  };
   AlignmentFlag hAlign =EnumUtils.enumFromSet (EnumUtils.mask ( it.alignment_, AlignmentFlag.AlignHorizontalMask));
   AlignmentFlag vAlign =EnumUtils.enumFromSet (EnumUtils.mask ( it.alignment_, AlignmentFlag.AlignVerticalMask));
  if ( orientation == Orientation.Horizontal) {
     boolean noAlign =false;
     String alignSelfStyle  = "";
    if ( vAlign != null) {
      switch (vAlign) {
        case Top: 
        alignSelfStyle=  "flex-start";
break;
        case Middle: 
        alignSelfStyle=  "center";
break;
        case Bottom: 
        alignSelfStyle=  "flex-end";
break;
        case Baseline: 
        alignSelfStyle=  "baseline";
break;
        default:
        noAlign = true;
break;
      }
    }
    else  {
      noAlign = true;
}
    if (noAlign) { 
       el.setProperty (Property.StyleFlex, "1 1 auto");
el =   this.wrap (el,  this.getStyleFlex());
  el.setProperty (Property.StyleFlex, "1 1 auto");
  el.setProperty (Property.StyleHeight, "100%");
el =   this.wrap (el,  this.getOtherStyleFlex());
  el.addPropertyWord (Property.Class, "Wt-fill-height");
}
    if ( hAlign != null) { 
       el.setProperty (Property.StyleFlex, "0 1 auto");
el =   this.wrap (el,  this.getStyleFlex());
  el.addPropertyWord (Property.Class, "Wt-justify-wrap");
switch (hAlign) {
        case Left: 
         el.setProperty (Property.StyleJustifyContent, "flex-start");
break;
        case Center: 
         el.setProperty (Property.StyleJustifyContent, "center");
break;
        case Right: 
         el.setProperty (Property.StyleJustifyContent, "flex-end");
default:
        break;
      }
    }
    if (alignSelfStyle.length()!=0) { 
       el.setProperty (Property.StyleAlignSelf, alignSelfStyle);
}
  }
  else  {
     boolean noAlign =false;
     String alignSelfStyle  = "";
    if ( hAlign != null) {
      switch (hAlign) {
        case Left: 
        alignSelfStyle=  "flex-start";
break;
        case Center: 
        alignSelfStyle=  "center";
break;
        case Right: 
        alignSelfStyle=  "flex-end";
break;
        default:
        noAlign = true;
break;
      }
    }
    else  {
      noAlign = true;
}
    if (noAlign) { 
       el.setProperty (Property.StyleFlex, "1 1 auto");
el =   this.wrap (el,  this.getOtherStyleFlex());
  el.addPropertyWord (Property.Class, "Wt-fill-width");
}
    if ( vAlign != null) { 
       el.setProperty (Property.StyleFlex, "0 1 auto");
el =   this.wrap (el,  this.getStyleFlex());
  el.addPropertyWord (Property.Class, "Wt-justify-wrap");
switch (vAlign) {
        case Top: 
         el.setProperty (Property.StyleJustifyContent, "flex-start");
break;
        case Middle: 
         el.setProperty (Property.StyleJustifyContent, "center");
break;
        case Bottom: 
         el.setProperty (Property.StyleJustifyContent, "flex-end");
default:
        break;
      }
    }
    if (alignSelfStyle.length()!=0) { 
       el.setProperty (Property.StyleAlignSelf, alignSelfStyle);
}
  } 
  {
     StringBuilder flexProperty  = new StringBuilder();
     int stretch =Math.max(0,  s.stretch_);
     int flexGrow =  totalStretch == 0? 1: stretch;
     int flexShrink =  totalStretch == 0? 1:   stretch == 0? 0: 1;
    flexProperty.append(flexGrow).append(' ').append(flexShrink).append(' ').append( s.initialSize_.getCssText());
if ( stretch == 0) { 
       el.setAttribute ("flg", "0");
} 
     el.setProperty (Property.StyleFlex, flexProperty.toString());
}
  switch (  this.getDirection ()) {
    case LeftToRight:
    if ( index != 0) {  
      m[3] +=  (    this.grid_.horizontalSpacing_ + 1) / 2;
}
    if ( index !=    this.count (orientation) - 1) {  
      m[1] +=     this.grid_.horizontalSpacing_ / 2;
}
    break;
    case RightToLeft:
    if ( index != 0) {  
      m[1] +=  (    this.grid_.horizontalSpacing_ + 1) / 2;
}
    if ( index !=    this.count (orientation) - 1) {  
      m[3] +=     this.grid_.horizontalSpacing_ / 2;
}
    break;
    case TopToBottom:
    if ( index != 0) {  
      m[0] +=  (    this.grid_.verticalSpacing_ + 1) / 2;
}
    if ( index !=    this.count (orientation) - 1) {  
      m[2] +=     this.grid_.verticalSpacing_ / 2;
}
    break;
    case BottomToTop:
    if ( index != 0) {  
      m[2] +=  (    this.grid_.verticalSpacing_ + 1) / 2;
}
    if ( index !=    this.count (orientation) - 1) {  
      m[0] +=     this.grid_.verticalSpacing_ / 2;
}
    break;
  }
  if (      m[0] != 0 ||    m[1] != 0 ||    m[2] != 0 ||    m[3] != 0) {
     StringBuilder marginProperty  = new StringBuilder();
    marginProperty.append(  m[0]).append("px ").append(  m[1]).append("px ").append(  m[2]).append("px ").append(  m[3]).append("px");
  el.setProperty (Property.StyleMargin, marginProperty.toString());
}
  return el;
  }
  private DomElement  wrap(DomElement  el, final String flow) {
   DomElement  wrapper =DomElement.createNew (DomElementType.DIV); 
   wrapper.setId ( "w" +  el.getId());
  wrapper.setProperty (Property.StyleDisplay,  this.getStyleDisplay());
  wrapper.setProperty (Property.StyleFlexFlow, flow);
  wrapper.addChild (el);
return wrapper;
  }
  private Orientation getOrientation() {
  switch (  this.getDirection ()) {
    case LeftToRight:
    case RightToLeft:
    return Orientation.Horizontal;
    case TopToBottom:
    case BottomToTop:
    return Orientation.Vertical;
  }
  return Orientation.Horizontal;
  }
  private LayoutDirection getDirection() {
   WBoxLayout  boxLayout =ObjectUtils.cast( this.getLayout(), WBoxLayout.class);
  if ( boxLayout != null) {
    return  boxLayout.getDirection();
  }
  else  {
    return LayoutDirection.LeftToRight;
  }
  }
  private String getStyleDisplay() {
  return     this.getContainer().isInline ()? "inline-flex": "flex";
  }
  private String getStyleFlex() {
  switch (  this.getDirection ()) {
    case LeftToRight:
    return "row";
    case RightToLeft:
    return "row-reverse";
    case TopToBottom:
    return "column";
    case BottomToTop:
    return "column-reverse";
  }
  return "";
  }
  private String getOtherStyleFlex() {
  switch (  this.getDirection ()) {
    case TopToBottom:
    return "row";
    case BottomToTop:
    return "row-reverse";
    case LeftToRight:
    return "column";
    case RightToLeft:
    return "column-reverse";
  }
  return "";
  }
  private int count(Orientation orientation) {
  return      this.grid_.rows_.size () *     this.grid_.columns_.size ();
  }
  private int indexOf(WLayoutItem  it, Orientation orientation) {
   int c =  this.count (orientation);
  for ( int i =0; 
  i < c;++ i) {
    if (    this.item (orientation, i).item_ == it) {
      return i;
    }
  }
  return - 1;
  }
  private int getTotalStretch(Orientation orientation) {
   int totalStretch =0;
   int c =  this.count (orientation);
  for ( int i =0; 
  i < c;++ i) {
     final Grid.Section s =  this.section (orientation, i);
     final Grid.Item it =  this.item (orientation, i);
    if ( ! (   it.item_.getWidget() != null) || !     it.item_.getWidget().isHidden ()) {
      totalStretch += Math.max(0,  s.stretch_);
}
  }
  return totalStretch;
  }
  private static StdLayoutImpl  getStdLayoutImpl(WLayoutItem  item) {
   WLayout  layout =ObjectUtils.cast(item, WLayout.class);
  if ( layout != null) {
    return ObjectUtils.cast( layout.getImpl(), StdLayoutImpl.class);
  }
  return null;
  }
  private Grid.Item item(Orientation orientation, int i) {
  if ( orientation == Orientation.Horizontal) {
    return    this.grid_.items_.get(0).get(i);
  }
  else  {
    return    this.grid_.items_.get(i).get(0);
  }
  }
  private Grid.Section section(Orientation orientation, int i) {
  if ( orientation == Orientation.Horizontal) {
    return    this.grid_.columns_.get(i);
  }
  else  {
    return    this.grid_.rows_.get(i);
  }
  }
   static WJavaScriptPreamble wtjs1() {
  return new WJavaScriptPreamble(JavaScriptScope.WtClassScope, JavaScriptObjectType.JavaScriptConstructor, "FlexLayout", "(function(t,e,s){const i=t.WT;function l(t,e){e.style.maxHeight=t.style.maxHeight;e.style.minHeight=t.style.minHeight;e.style.maxWidth=t.style.maxWidth;e.style.minWidth=t.style.minWidth}setTimeout((function(){const t=i.getElement(e);if(t){\"none\"===t.style.maxHeight||\"\"===t.style.maxHeight||\"auto\"!==t.style.height&&\"\"!==t.style.height||(t.style.height=\"fit-content\");\"none\"===t.style.maxWidth||\"\"===t.style.maxWidth||\"auto\"!==t.style.width&&\"\"!==t.style.width||(t.style.width=\"fit-content\");for(const e of t.childNodes){if(\"none\"===e.style.display||e.classList.contains(\"out\")||\"resize-sensor\"===e.className)continue;const t=i.css(e,\"overflow\");\"visible\"!==t&&\"\"!==t||(e.style.overflow=\"hidden\");const n=e.classList.contains(\"Wt-justify-wrap\")?e.childNodes[0]:e;if(n.classList.contains(\"Wt-fill-width\")){const t=n.children[0];n.style.flexBasis=t.style.height;t.style.height=\"auto\";l(t,n)}if(n.classList.contains(\"Wt-fill-height\")){const t=n.children[0],o=t.children[0];e.style.flexBasis=o.style.width;n.style.flexBasis=o.style.width;t.style.flexBasis=o.style.height;o.style.height=\"auto\";l(o,n);const c=i.getElement(s);setTimeout((function(){c&&\"fit-content\"!==c.style.width&&(o.style.width=\"auto\")}),0)}}}}),0);this.resizeItem=function(t,e,s){setTimeout(n,0,t,e,s)};function n(t,e,n){if(!t)return;let o=t.parentElement;if(o){if(o.classList.contains(\"Wt-fill-width\")){o.style.flexBasis=n;t.style.height=\"auto\";l(t,o)}o=o.parentElement;if(o&&o.classList.contains(\"Wt-fill-height\")){const c=o.parentElement;c&&c.classList.contains(\"Wt-justify-wrap\")&&(c.style.flexBasis=e);o.style.flexBasis=e;o.children[0].style.flexBasis=n;t.style.height=\"auto\";l(t,o);const a=i.getElement(s);setTimeout((function(){a&&\"fit-content\"!==a.style.width&&(t.style.width=\"auto\")}),0)}}}this.adjust=function(){setTimeout((function(){const t=i.getElement(e);if(!t)return;const l=t.childNodes;let n=0;for(const t of l){if(\"none\"===t.style.display||t.classList.contains(\"out\")||\"resize-sensor\"===t.className)continue;if(\"0\"===t.getAttribute(\"flg\"))continue;const e=i.css(t,\"flex-grow\");n+=parseFloat(e)}for(const t of l){if(\"none\"===t.style.display||t.classList.contains(\"out\")||\"resize-sensor\"===t.className)continue;t.resizeSensor&&t.resizeSensor.trigger();let e;if(0===n)e=1;else{if(\"0\"===t.getAttribute(\"flg\"))e=0;else{e=i.css(t,\"flex-grow\")}}t.style.flexGrow=e;const l=t.classList.contains(\"Wt-justify-wrap\")?t.childNodes[0]:t;if(l.classList.contains(\"Wt-fill-height\")){const t=i.getElement(s);if(t&&\"fit-content\"!==t.style.width){l.childNodes[0].childNodes[0].style.width=\"auto\"}}}}),0)}})");
  }
}
